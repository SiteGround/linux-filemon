diff -rup linux-3.8.6/fs/dcache.c linux-3.8.6-mm/fs/dcache.c
--- linux-3.8.6/fs/dcache.c	2013-04-05 11:49:06.000000000 -0500
+++ linux-3.8.6-mm/fs/dcache.c	2013-06-04 13:23:16.694497049 -0500
@@ -217,6 +217,17 @@ static inline int dentry_cmp(const struc
 static void __d_free(struct rcu_head *head)
 {
 	struct dentry *dentry = container_of(head, struct dentry, d_u.d_rcu);
+#ifdef CONFIG_FILEMON
+	int i;
+
+	for (i = 0; i < 2; i++) {
+		struct filemon_info *info = &dentry->d_filemon[i];
+	        if (unlikely(!list_empty(&info->fi_dirty))) {
+			printk("filemon dentry %p not empty at %d\n", dentry, i);
+			return;
+		}
+	}
+#endif
 
 	WARN_ON(!hlist_unhashed(&dentry->d_alias));
 	if (dname_external(dentry))
@@ -994,6 +1005,8 @@ void shrink_dcache_for_umount(struct sup
 	if (down_read_trylock(&sb->s_umount))
 		BUG();
 
+	filemon_killall_dirty(sb);
+
 	dentry = sb->s_root;
 	sb->s_root = NULL;
 	dentry->d_count--;
@@ -1297,6 +1310,19 @@ struct dentry *__d_alloc(struct super_bl
 	INIT_HLIST_NODE(&dentry->d_alias);
 	INIT_LIST_HEAD(&dentry->d_u.d_child);
 	d_set_d_op(dentry, dentry->d_sb->s_d_op);
+#ifdef CONFIG_FILEMON
+	{
+		int i;
+		for(i = 0; i < FILEMON_MAX; i++) {
+			struct filemon_info *info = &dentry->d_filemon[i];
+			INIT_LIST_HEAD(&info->fi_dirty);
+			info->fi_fflags = 0;
+#ifdef CONFIG_FILEMON_COUNTERS
+			memset(info->fi_counter, 0, sizeof(info->fi_counter));
+#endif
+		}
+	}
+#endif
 
 	this_cpu_inc(nr_dentry);
 
@@ -2187,12 +2213,25 @@ static void switch_names(struct dentry *
 			target->d_name.name = dentry->d_name.name;
 			dentry->d_name.name = dentry->d_iname;
 		} else {
+#ifdef CONFIG_FILEMON
 			/*
-			 * Both are internal.  Just copy target to dentry
+			 * Both are internal.
+                         * Make the full exchange because we need to remember
+                         * the old name correctly.
 			 */
+			char tmpname[DNAME_INLINE_LEN];
+			unsigned int tmplen = dentry->d_name.len;
+			memcpy(tmpname, dentry->d_name.name,
+			       tmplen + 1);
+#endif //CONFIG_FILEMON
 			memcpy(dentry->d_iname, target->d_name.name,
 					target->d_name.len + 1);
 			dentry->d_name.len = target->d_name.len;
+#ifdef CONFIG_FILEMON
+			memcpy(target->d_iname, tmpname, 
+			       tmplen + 1);
+			target->d_name.len = tmplen;
+#endif //CONFIG_FILEMON
 			return;
 		}
 	}
@@ -2264,6 +2303,8 @@ static void __d_move(struct dentry * den
 	BUG_ON(d_ancestor(dentry, target));
 	BUG_ON(d_ancestor(target, dentry));
 
+	fsnotify_d_move_from(target);
+
 	dentry_lock_for_move(dentry, target);
 
 	write_seqcount_begin(&dentry->d_seq);
@@ -2309,6 +2350,7 @@ static void __d_move(struct dentry * den
 	spin_unlock(&target->d_lock);
 	fsnotify_d_move(dentry);
 	spin_unlock(&dentry->d_lock);
+	fsnotify_d_move_to(dentry);
 }
 
 /*
diff -rup linux-3.8.6/fs/locks.c linux-3.8.6-mm/fs/locks.c
--- linux-3.8.6/fs/locks.c	2013-04-05 11:49:06.000000000 -0500
+++ linux-3.8.6-mm/fs/locks.c	2013-06-04 13:23:16.694497049 -0500
@@ -124,6 +124,7 @@
 #include <linux/slab.h>
 #include <linux/syscalls.h>
 #include <linux/time.h>
+#include <linux/fsnotify.h>
 #include <linux/rcupdate.h>
 #include <linux/pid_namespace.h>
 
@@ -1652,6 +1653,8 @@ SYSCALL_DEFINE2(flock, unsigned int, fd,
 	if (error)
 		goto out_free;
 
+	fsnotify_flock(filp->f_path.dentry);
+
 	if (f.file->f_op && f.file->f_op->flock)
 		error = f.file->f_op->flock(f.file,
 					  (can_sleep) ? F_SETLKW : F_SETLK,
@@ -1790,6 +1793,8 @@ out:
  */
 int vfs_lock_file(struct file *filp, unsigned int cmd, struct file_lock *fl, struct file_lock *conf)
 {
+	fsnotify_plock(filp->f_path.dentry);
+
 	if (filp->f_op && filp->f_op->lock)
 		return filp->f_op->lock(filp, cmd, fl);
 	else
diff -rup linux-3.8.6/fs/namespace.c linux-3.8.6-mm/fs/namespace.c
--- linux-3.8.6/fs/namespace.c	2013-04-05 11:49:06.000000000 -0500
+++ linux-3.8.6-mm/fs/namespace.c	2013-06-04 13:23:16.694497049 -0500
@@ -1187,6 +1187,8 @@ static int do_umount(struct mount *mnt, 
 			return -EAGAIN;
 	}
 
+	fsnotify_umount(&mnt->mnt, mnt->mnt_mountpoint, sb);
+
 	/*
 	 * If we may have to abort operations to get out of this
 	 * mount, and they will themselves hold resources we must
@@ -2306,6 +2308,9 @@ long do_mount(const char *dev_name, cons
 	else
 		retval = do_new_mount(&path, type_page, flags, mnt_flags,
 				      dev_name, data_page);
+
+	if(!retval)
+		fsnotify_mount(path.dentry);
 dput_out:
 	path_put(&path);
 	return retval;
diff -rup linux-3.8.6/fs/notify/Kconfig linux-3.8.6-mm/fs/notify/Kconfig
--- linux-3.8.6/fs/notify/Kconfig	2013-04-05 11:49:06.000000000 -0500
+++ linux-3.8.6-mm/fs/notify/Kconfig	2013-06-04 13:23:16.694497049 -0500
@@ -1,6 +1,25 @@
 config FSNOTIFY
 	def_bool n
 
+config FILEMON
+       bool "Filemonitor notification support"
+       default y
+       ---help---
+         Say Y here to enable filemonitor support.  Filemonitor is a file change
+         notification system different from inotify. It supports long-term
+         monitoring in kernel space, absolute path resolution including
+         mountpoints.
+
+         If unsure, say N.
+
+config FILEMON_COUNTERS
+       bool "Detailed hit counters for filemon"
+       depends on FILEMON
+       default n
+       ---help---
+         Enable counters for filemon, nut just flag bits.
+         Uses up more space. If unsure, say N.
+
 source "fs/notify/dnotify/Kconfig"
 source "fs/notify/inotify/Kconfig"
 source "fs/notify/fanotify/Kconfig"
diff -rup linux-3.8.6/fs/notify/Makefile linux-3.8.6-mm/fs/notify/Makefile
--- linux-3.8.6/fs/notify/Makefile	2013-04-05 11:49:06.000000000 -0500
+++ linux-3.8.6-mm/fs/notify/Makefile	2013-06-04 13:23:16.694497049 -0500
@@ -1,6 +1,7 @@
 obj-$(CONFIG_FSNOTIFY)		+= fsnotify.o notification.o group.o inode_mark.o \
 				   mark.o vfsmount_mark.o fdinfo.o
 
+obj-$(CONFIG_FILEMON)           += filemon.o
 obj-y			+= dnotify/
 obj-y			+= inotify/
 obj-y			+= fanotify/
diff -rup linux-3.8.6/fs/readdir.c linux-3.8.6-mm/fs/readdir.c
--- linux-3.8.6/fs/readdir.c	2013-04-05 11:49:06.000000000 -0500
+++ linux-3.8.6-mm/fs/readdir.c	2013-06-04 13:23:16.694497049 -0500
@@ -17,6 +17,7 @@
 #include <linux/security.h>
 #include <linux/syscalls.h>
 #include <linux/unistd.h>
+#include <linux/fsnotify.h>
 
 #include <asm/uaccess.h>
 
@@ -39,6 +40,7 @@ int vfs_readdir(struct file *file, filld
 	if (!IS_DEADDIR(inode)) {
 		res = file->f_op->readdir(file, buf, filler);
 		file_accessed(file);
+		fsnotify_readdir(file->f_path.dentry);
 	}
 	mutex_unlock(&inode->i_mutex);
 out:
diff -rup linux-3.8.6/fs/stat.c linux-3.8.6-mm/fs/stat.c
--- linux-3.8.6/fs/stat.c	2013-04-05 11:49:06.000000000 -0500
+++ linux-3.8.6-mm/fs/stat.c	2013-06-04 13:23:16.694497049 -0500
@@ -14,6 +14,7 @@
 #include <linux/security.h>
 #include <linux/syscalls.h>
 #include <linux/pagemap.h>
+#include <linux/fsnotify.h>
 
 #include <asm/uaccess.h>
 #include <asm/unistd.h>
@@ -42,6 +43,8 @@ int vfs_getattr(struct vfsmount *mnt, st
 	struct inode *inode = dentry->d_inode;
 	int retval;
 
+	fsnotify_stat(dentry);
+
 	retval = security_inode_getattr(mnt, dentry);
 	if (retval)
 		return retval;
diff -rup linux-3.8.6/include/linux/dcache.h linux-3.8.6-mm/include/linux/dcache.h
--- linux-3.8.6/include/linux/dcache.h	2013-04-05 11:49:06.000000000 -0500
+++ linux-3.8.6-mm/include/linux/dcache.h	2013-06-04 13:23:16.694497049 -0500
@@ -9,6 +9,8 @@
 #include <linux/seqlock.h>
 #include <linux/cache.h>
 #include <linux/rcupdate.h>
+#include <linux/time.h>
+#include <linux/filemon_defs.h>
 
 struct nameidata;
 struct path;
@@ -129,6 +131,9 @@ struct dentry {
 	} d_u;
 	struct list_head d_subdirs;	/* our children */
 	struct hlist_node d_alias;	/* inode alias list */
+#ifdef CONFIG_FILEMON
+	struct filemon_info d_filemon[FILEMON_MAX];
+#endif
 };
 
 /*
diff -rup linux-3.8.6/include/linux/fsnotify.h linux-3.8.6-mm/include/linux/fsnotify.h
--- linux-3.8.6/include/linux/fsnotify.h	2013-04-05 11:49:06.000000000 -0500
+++ linux-3.8.6-mm/include/linux/fsnotify.h	2013-06-04 13:23:16.694497049 -0500
@@ -15,6 +15,27 @@
 #include <linux/audit.h>
 #include <linux/slab.h>
 #include <linux/bug.h>
+#include <linux/mount.h>
+#include <linux/filemon.h>
+
+/*
+ * fsnotify_mount - tell that many many things have changed...
+ */
+static inline void fsnotify_mount(struct dentry *dentry)
+{
+	d_dirtify(dentry, FM_MOUNT);
+}
+
+/*
+ * fsnotify_umount - tell that many many things might have changed...
+ */
+static inline void fsnotify_umount(struct vfsmount *mnt, struct dentry *mnt_mountpoint, struct super_block *sb)
+{
+	d_dirtify(mnt_mountpoint, FM_UMOUNT);
+	if(sb->s_root != mnt->mnt_root)
+		d_dirtify(sb->s_root, FM_UMOUNT);	
+	filemon_killall_dirty(sb);
+}
 
 /*
  * fsnotify_d_instantiate - instantiate a dentry for inode
@@ -22,6 +43,7 @@
 static inline void fsnotify_d_instantiate(struct dentry *dentry,
 					  struct inode *inode)
 {
+	d_dirtify(dentry, FM_NEW);
 	__fsnotify_d_instantiate(dentry, inode);
 }
 
@@ -73,6 +95,19 @@ static inline void fsnotify_d_move(struc
 }
 
 /*
+ * fsnotify_d_move_{from,to} - entry has been moved
+ */
+static inline void fsnotify_d_move_from(struct dentry *target)
+{
+	d_dirtify(target, FM_MOVED_FROM);
+}
+
+static inline void fsnotify_d_move_to(struct dentry *dentry)
+{
+	d_dirtify(dentry, FM_MOVED_TO);
+}
+
+/*
  * fsnotify_link_count - inode's link count changed
  */
 static inline void fsnotify_link_count(struct inode *inode)
@@ -138,6 +173,7 @@ static inline void fsnotify_nameremove(s
 	if (isdir)
 		mask |= FS_ISDIR;
 
+	d_dirtify(dentry, FM_DELETE);
 	fsnotify_parent(NULL, dentry, mask);
 }
 
@@ -155,6 +191,7 @@ static inline void fsnotify_inoderemove(
  */
 static inline void fsnotify_create(struct inode *inode, struct dentry *dentry)
 {
+	d_dirtify(dentry, FM_CREATE);
 	audit_inode_child(inode, dentry, AUDIT_TYPE_CHILD_CREATE);
 
 	fsnotify(inode, FS_CREATE, dentry->d_inode, FSNOTIFY_EVENT_INODE, dentry->d_name.name, 0);
@@ -167,6 +204,7 @@ static inline void fsnotify_create(struc
  */
 static inline void fsnotify_link(struct inode *dir, struct inode *inode, struct dentry *new_dentry)
 {
+	d_dirtify(new_dentry, FM_LINK);
 	fsnotify_link_count(inode);
 	audit_inode_child(dir, new_dentry, AUDIT_TYPE_CHILD_CREATE);
 
@@ -181,6 +219,7 @@ static inline void fsnotify_mkdir(struct
 	__u32 mask = (FS_CREATE | FS_ISDIR);
 	struct inode *d_inode = dentry->d_inode;
 
+	d_dirtify(dentry, FM_MKDIR);
 	audit_inode_child(inode, dentry, AUDIT_TYPE_CHILD_CREATE);
 
 	fsnotify(inode, mask, d_inode, FSNOTIFY_EVENT_INODE, dentry->d_name.name, 0);
@@ -195,6 +234,7 @@ static inline void fsnotify_access(struc
 	struct inode *inode = path->dentry->d_inode;
 	__u32 mask = FS_ACCESS;
 
+	d_dirtify(path->dentry, FM_READ);
 	if (S_ISDIR(inode->i_mode))
 		mask |= FS_ISDIR;
 
@@ -216,6 +256,7 @@ static inline void fsnotify_modify(struc
 	if (S_ISDIR(inode->i_mode))
 		mask |= FS_ISDIR;
 
+	d_dirtify(path->dentry, FM_WRITE);
 	if (!(file->f_mode & FMODE_NONOTIFY)) {
 		fsnotify_parent(path, NULL, mask);
 		fsnotify(inode, mask, path, FSNOTIFY_EVENT_PATH, NULL, 0);
@@ -223,6 +264,38 @@ static inline void fsnotify_modify(struc
 }
 
 /*
+ * fsnotify_stat - file was stat'ed
+ */
+static inline void fsnotify_stat(struct dentry *dentry)
+{
+	d_dirtify(dentry, FM_STAT);
+}
+
+/*
+ * fsnotify_readdir - directory was read
+ */
+static inline void fsnotify_readdir(struct dentry *dentry)
+{
+	d_dirtify(dentry, FM_READDIR);
+}
+
+/*
+ * fsnotify_flock - a lock operation has started
+ */
+static inline void fsnotify_flock(struct dentry *dentry)
+{
+	d_dirtify(dentry, FM_FLOCK);
+}
+
+/*
+ * fsnotify_plock - a POSIX lock operation has started
+ */
+static inline void fsnotify_plock(struct dentry *dentry)
+{
+	d_dirtify(dentry, FM_PLOCK);
+}
+
+/*
  * fsnotify_open - file was opened
  */
 static inline void fsnotify_open(struct file *file)
@@ -234,6 +307,7 @@ static inline void fsnotify_open(struct 
 	if (S_ISDIR(inode->i_mode))
 		mask |= FS_ISDIR;
 
+	d_dirtify(path->dentry, FM_OPEN);
 	fsnotify_parent(path, NULL, mask);
 	fsnotify(inode, mask, path, FSNOTIFY_EVENT_PATH, NULL, 0);
 }
@@ -251,6 +325,7 @@ static inline void fsnotify_close(struct
 	if (S_ISDIR(inode->i_mode))
 		mask |= FS_ISDIR;
 
+	d_dirtify(path->dentry, FM_CLOSE);
 	if (!(file->f_mode & FMODE_NONOTIFY)) {
 		fsnotify_parent(path, NULL, mask);
 		fsnotify(inode, mask, path, FSNOTIFY_EVENT_PATH, NULL, 0);
@@ -268,6 +343,7 @@ static inline void fsnotify_xattr(struct
 	if (S_ISDIR(inode->i_mode))
 		mask |= FS_ISDIR;
 
+	d_dirtify(dentry, FM_XATTR);
 	fsnotify_parent(NULL, dentry, mask);
 	fsnotify(inode, mask, inode, FSNOTIFY_EVENT_INODE, NULL, 0);
 }
@@ -299,6 +375,13 @@ static inline void fsnotify_change(struc
 	if (ia_valid & ATTR_MODE)
 		mask |= FS_ATTRIB;
 
+
+#ifdef CONFIG_FILEMON
+	if (ia_valid & ATTR_UID || ia_valid & ATTR_GID || ia_valid & ATTR_MODE || (ia_valid & ATTR_ATIME && ia_valid & ATTR_MTIME))
+		d_dirtify(dentry, FM_ATTR);
+	if (ia_valid & ATTR_SIZE || ((ia_valid & ATTR_MTIME) && ~(ia_valid & ATTR_ATIME)))
+		d_dirtify(dentry, FM_MODIFY);
+#endif
 	if (mask) {
 		if (S_ISDIR(inode->i_mode))
 			mask |= FS_ISDIR;
diff -rup linux-3.8.6/include/uapi/linux/sysctl.h linux-3.8.6-mm/include/uapi/linux/sysctl.h
--- linux-3.8.6/include/uapi/linux/sysctl.h	2013-04-05 11:49:06.000000000 -0500
+++ linux-3.8.6-mm/include/uapi/linux/sysctl.h	2013-06-04 13:23:16.694497049 -0500
@@ -80,6 +80,19 @@ enum
 	INOTIFY_MAX_QUEUED_EVENTS=3	/* max queued events per instance */
 };
 
+/* /proc/sys/fs/filemon/ */
+enum
+{
+	FILEMON_MASK=1,				/* which events to record */
+	FILEMON_MAX_COUNT=2,		/* max number of pinned dentries */
+	FILEMON_OVERFLOW=3,			/* overflow flag */
+	FILEMON_MSLEEP=4,			/* additional sleep time after wakeup (allow heuristic aggregation of notifications) */
+	FILEMON_DIRTY_COUNT_0=5,	/* number of changed files */
+	FILEMON_DIRTY_COUNT_1=6,	/* number of changed files */
+	FILEMON_DIRTY_COUNT_2=7,	/* number of changed files */
+	FILEMON_VERSION=19			/* filemon kernel patch version */
+};
+
 /* CTL_KERN names: */
 enum
 {
@@ -820,6 +833,7 @@ enum
 	FS_AIO_NR=18,	/* current system-wide number of aio requests */
 	FS_AIO_MAX_NR=19,	/* system-wide maximum number of aio requests */
 	FS_INOTIFY=20,	/* inotify submenu */
+	FS_FILEMON=21,  /* filemonitor submenu */
 	FS_OCFS2=988,	/* ocfs2 */
 };
 
diff -rup linux-3.8.6/kernel/sys.c linux-3.8.6-mm/kernel/sys.c
--- linux-3.8.6/kernel/sys.c	2013-04-05 11:49:06.000000000 -0500
+++ linux-3.8.6-mm/kernel/sys.c	2013-06-04 13:23:16.694497049 -0500
@@ -31,6 +31,7 @@
 #include <linux/cn_proc.h>
 #include <linux/getcpu.h>
 #include <linux/task_io_accounting_ops.h>
+#include <linux/filemon.h>
 #include <linux/seccomp.h>
 #include <linux/cpu.h>
 #include <linux/personality.h>
@@ -380,6 +381,7 @@ EXPORT_SYMBOL_GPL(kernel_restart);
 
 static void kernel_shutdown_prepare(enum system_states state)
 {
+	filemon_killall_dirty(NULL);
 	blocking_notifier_call_chain(&reboot_notifier_list,
 		(state == SYSTEM_HALT)?SYS_HALT:SYS_POWER_OFF, NULL);
 	system_state = state;
diff -rup linux-3.8.6/kernel/sysctl.c linux-3.8.6-mm/kernel/sysctl.c
--- linux-3.8.6/kernel/sysctl.c	2013-04-05 11:49:06.000000000 -0500
+++ linux-3.8.6-mm/kernel/sysctl.c	2013-06-04 13:23:16.694497049 -0500
@@ -215,6 +215,9 @@ extern struct ctl_table random_table[];
 #ifdef CONFIG_EPOLL
 extern struct ctl_table epoll_table[];
 #endif
+#ifdef CONFIG_FILEMON
+extern struct ctl_table filemon_table[];
+#endif
 
 #ifdef HAVE_ARCH_PICK_MMAP_LAYOUT
 int sysctl_legacy_va_layout;
@@ -1536,6 +1539,13 @@ static struct ctl_table fs_table[] = {
 		.child		= inotify_table,
 	},
 #endif	
+#ifdef CONFIG_FILEMON
+	{
+		.procname	= "filemon",
+		.mode		= 0555,
+		.child		= filemon_table,
+	},
+#endif
 #ifdef CONFIG_EPOLL
 	{
 		.procname	= "epoll",
diff -rup linux-3.8.6/mm/memory.c linux-3.8.6-mm/mm/memory.c
--- linux-3.8.6/mm/memory.c	2013-04-05 11:49:06.000000000 -0500
+++ linux-3.8.6-mm/mm/memory.c	2013-06-04 13:23:16.704497049 -0500
@@ -4073,6 +4073,7 @@ static int __access_remote_vm(struct tas
 
 	return buf - old_buf;
 }
+EXPORT_SYMBOL(access_process_vm);
 
 /**
  * access_remote_vm - access another process' address space
